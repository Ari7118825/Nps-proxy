<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Integrated CORS Tunnel</title>
    <style>
        body, html { margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; background: #111; }
        iframe { width: 100%; height: 100%; border: none; }
        #loading { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-family: sans-serif; }
    </style>
</head>
<body>

    <div id="loading">Initializing Tunnel...</div>
    <iframe id="proxyFrame" style="display:none;"></iframe>

    <script>
        const proxyBase = "https://api.codetabs.com/v1/proxy?quest=";
        const targetDomain = "https://www.croxyproxy.com";

        // --- 1. Define the Service Worker Logic as a String ---
        const swCode = `
            const proxyBase = "${proxyBase}";
            const targetDomain = "${targetDomain}";

            self.addEventListener('fetch', (event) => {
                const url = new URL(event.request.url);

                // Skip CodeTabs and direct IP addresses (Proxy Servers)
                if (url.href.includes('codetabs.com')) return;
                const isIP = /^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$/.test(url.hostname);
                if (isIP) return;

                // Force all requests to targetDomain if they are coming from our origin
                let destinationUrl = event.request.url;
                if (url.origin === self.location.origin) {
                    destinationUrl = targetDomain + url.pathname + url.search;
                }

                const tunneledUrl = proxyBase + encodeURIComponent(destinationUrl);

                event.respondWith(
                    fetch(tunneledUrl, {
                        method: event.request.method,
                        headers: event.request.headers,
                        redirect: 'manual' 
                    }).then(response => {
                        // Catch internal redirects and re-tunnel them
                        if (response.type === 'opaqueredirect' || (response.status >= 300 && response.status < 400)) {
                            const newLocation = response.headers.get('Location');
                            return fetch(proxyBase + encodeURIComponent(newLocation));
                        }
                        return response;
                    })
                );
            });
        `;

        // --- 2. Register the Service Worker via Blob ---
        async function setupProxy() {
            if ('serviceWorker' in navigator) {
                const blob = new Blob([swCode], { type: 'application/javascript' });
                const workerUrl = URL.createObjectURL(blob);

                try {
                    const reg = await navigator.serviceWorker.register(workerUrl, { scope: '/' });
                    await navigator.serviceWorker.ready;
                    
                    // Small delay to ensure the worker is fully activated before the first fetch
                    setTimeout(() => {
                        const iframe = document.getElementById('proxyFrame');
                        iframe.src = proxyBase + encodeURIComponent(targetDomain + '/');
                        iframe.style.display = 'block';
                        document.getElementById('loading').style.display = 'none';
                    }, 500);

                } catch (err) {
                    document.getElementById('loading').innerText = "Worker Error: " + err;
                }
            } else {
                document.getElementById('loading').innerText = "Service Workers not supported.";
            }
        }

        // --- 3. Prevent the Iframe from breaking out ---
        // This stops scripts that try to change top.location.href
        window.onbeforeunload = function() {
            return "Redirect blocked";
        };

        setupProxy();
    </script>
</body>
</html>
