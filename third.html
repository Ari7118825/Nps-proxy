<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Static Advanced Web Proxy</title>
    <style>
        :root {
            --bg: #1a1a1a;
            --accent: #3b82f6;
            --text: #ffffff;
        }
        body, html { 
            margin: 0; padding: 0; height: 100%; width: 100%;
            background: var(--bg); color: var(--text); font-family: -apple-system, sans-serif;
            display: flex; flex-direction: column; overflow: hidden;
        }
        #nav {
            display: flex; align-items: center; padding: 10px 15px;
            background: #252525; border-bottom: 1px solid #333; gap: 10px;
        }
        #urlInput {
            flex: 1; padding: 10px; border-radius: 6px; border: 1px solid #444;
            background: #000; color: #fff; outline: none; transition: border-color 0.2s;
        }
        #urlInput:focus { border-color: var(--accent); }
        button {
            padding: 10px 20px; border-radius: 6px; border: none;
            background: var(--accent); color: white; font-weight: bold;
            cursor: pointer; transition: opacity 0.2s;
        }
        button:hover { opacity: 0.9; }
        #frameContainer { flex: 1; width: 100%; position: relative; background: #fff; }
        iframe { width: 100%; height: 100%; border: none; }
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 4px;
            background: var(--accent); transform: scaleX(0); transform-origin: left;
            transition: transform 0.3s;
        }
    </style>
</head>
<body>

<div id="nav">
    <div style="font-weight: bold; color: var(--accent);">PROXY</div>
    <input type="text" id="urlInput" placeholder="https://example.com" onkeydown="if(event.key==='Enter') navigate()">
    <button onclick="navigate()">Go</button>
</div>

<div id="frameContainer">
    <div id="loader"></div>
    <iframe id="proxyFrame" sandbox="allow-same-origin allow-scripts allow-forms allow-popups"></iframe>
</div>

<script>
    // Proxy Pool for rotation and fallback
    const PROXY_POOL = [
        "https://api.codetabs.com/v1/proxy?quest=",
        "https://api.allorigins.win/raw?url=",
        "https://thingproxy.freeboard.io/fetch/"
    ];

    const frame = document.getElementById('proxyFrame');
    const input = document.getElementById('urlInput');
    const loader = document.getElementById('loader');

    async function navigate() {
        let url = input.value.trim();
        if (!url) return;
        if (!/^https?:\/\//i.test(url)) url = 'https://' + url;
        
        showLoader(true);
        
        // Try proxies in order for the main document
        let html = null;
        let successfulProxy = PROXY_POOL[0];

        for (const proxyBase of PROXY_POOL) {
            try {
                const response = await fetch(proxyBase + encodeURIComponent(url));
                if (response.ok) {
                    html = await response.text();
                    successfulProxy = proxyBase;
                    break;
                }
            } catch (err) {
                console.warn(`Proxy ${proxyBase} failed, trying next...`);
            }
        }

        if (!html) {
            alert("All proxies failed to fetch this site.");
            showLoader(false);
            return;
        }
        
        try {
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const urlObj = new URL(url);

            const fixUrl = (original, proxy) => {
                if (!original || typeof original !== 'string') return original;
                if (original.startsWith('data:') || original.startsWith('javascript:')) return original;
                try {
                    const resolved = new URL(original, urlObj.href).href;
                    // Prevent double proxying
                    for (const p of PROXY_POOL) if (resolved.startsWith(p)) return resolved;
                    return (proxy || successfulProxy) + encodeURIComponent(resolved);
                } catch (e) {
                    return original;
                }
            };

            // 1. Initial Static Rewrite
            const attributesToFix = ['href', 'src', 'action', 'srcset', 'data-src'];
            doc.querySelectorAll('*').forEach(el => {
                attributesToFix.forEach(attr => {
                    if (el.hasAttribute(attr)) {
                        const val = el.getAttribute(attr);
                        if (val && !val.startsWith('#')) {
                            el.setAttribute(attr, fixUrl(val));
                        }
                    }
                });
            });

            // 2. Inject Advanced Interceptor with Rotation Logic
            const script = doc.createElement('script');
            script.textContent = `
                (function() {
                    const PROXY_POOL = ${JSON.stringify(PROXY_POOL)};
                    const BASE_URL = "${urlObj.href}";

                    function wrapUrl(url, proxyIndex = 0) {
                        if (!url || typeof url !== 'string') return url;
                        if (url.startsWith('data:') || url.startsWith('javascript:')) return url;
                        // Check if already proxied
                        for (const p of PROXY_POOL) if (url.startsWith(p)) return url;
                        
                        try {
                            const resolved = new URL(url, BASE_URL).href;
                            return PROXY_POOL[proxyIndex] + encodeURIComponent(resolved);
                        } catch(e) { return url; }
                    }

                    // --- PATCH FETCH WITH AUTO-RETRY ---
                    const originalFetch = window.fetch;
                    window.fetch = async function(resource, init) {
                        let url = (typeof resource === 'string') ? resource : resource.url;
                        
                        for (let i = 0; i < PROXY_POOL.length; i++) {
                            try {
                                const proxiedUrl = wrapUrl(url, i);
                                const newResource = (resource instanceof Request) ? new Request(proxiedUrl, resource) : proxiedUrl;
                                const response = await originalFetch.call(this, newResource, init);
                                if (response.ok || i === PROXY_POOL.length - 1) return response;
                            } catch (err) {
                                if (i === PROXY_POOL.length - 1) throw err;
                                console.warn("Fetch failed on proxy " + i + ", retrying...");
                            }
                        }
                    };

                    // --- PATCH XHR WITH AUTO-RETRY ---
                    const originalOpen = XMLHttpRequest.prototype.open;
                    const originalSend = XMLHttpRequest.prototype.send;
                    
                    XMLHttpRequest.prototype.open = function(method, url, ...args) {
                        this._url = url;
                        this._method = method;
                        this._args = args;
                        this._proxyIndex = 0;
                        return originalOpen.apply(this, [method, wrapUrl(url, 0), ...args]);
                    };

                    // Note: True XHR retry logic is complex for a static script, 
                    // but wrapUrl(0) provides the first line of defense.

                    // --- PATCH PROTOTYPES ---
                    const descriptors = [
                        { obj: HTMLImageElement.prototype, prop: 'src' },
                        { obj: HTMLScriptElement.prototype, prop: 'src' },
                        { obj: HTMLIFrameElement.prototype, prop: 'src' },
                        { obj: HTMLLinkElement.prototype, prop: 'href' }
                    ];

                    descriptors.forEach(({ obj, prop }) => {
                        const originalDescriptor = Object.getOwnPropertyDescriptor(obj, prop);
                        Object.defineProperty(obj, prop, {
                            get: function() { return originalDescriptor.get.call(this); },
                            set: function(val) {
                                return originalDescriptor.set.call(this, wrapUrl(val, 0));
                            },
                            configurable: true
                        });
                    });

                    // --- NAVIGATION & DOM WATCHER ---
                    document.addEventListener('click', e => {
                        const a = e.target.closest('a');
                        if (a && a.href && !a.href.startsWith('#')) {
                            // Extract original URL from any of the proxies
                            let finalUrl = a.href;
                            for (const p of PROXY_POOL) {
                                if (finalUrl.startsWith(p)) {
                                    finalUrl = decodeURIComponent(finalUrl.replace(p, ""));
                                    break;
                                }
                            }
                            e.preventDefault();
                            window.parent.postMessage({ type: 'proxyNav', url: finalUrl }, '*');
                        }
                    });

                    const observer = new MutationObserver(mutations => {
                        mutations.forEach(mutation => {
                            mutation.addedNodes.forEach(node => {
                                if (node.nodeType === 1) {
                                    if (node.tagName === 'A') node.href = wrapUrl(node.href, 0);
                                    else if (node.src) node.src = wrapUrl(node.src, 0);
                                }
                            });
                        });
                    });
                    observer.observe(document, { childList: true, subtree: true });
                })();
            `;
            doc.head.prepend(script);

            frame.srcdoc = doc.documentElement.outerHTML;
            
        } catch (err) {
            console.error("Proxy processing error:", err);
            alert("Error processing page content.");
        } finally {
            showLoader(false);
        }
    }

    window.addEventListener('message', e => {
        if (e.data && e.data.type === 'proxyNav') {
            input.value = e.data.url;
            navigate();
        }
    });

    function showLoader(show) {
        loader.style.transform = show ? 'scaleX(1)' : 'scaleX(0)';
    }
</script>

</body>
</html>
